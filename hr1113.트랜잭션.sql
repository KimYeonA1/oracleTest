--Transaction 
DROP TABLE DEP02;
--테이블복사 (구조만 복사)
CREATE TABLE DEP02
AS
SELECT * FROM DEPARTMENTS WHERE 1 = 0; 
---------------------여기까지 커밋 됨 , 롤백하면 여기 위치까지 됨
--테이블복사 (내용만 복사)
INSERT INTO DEP02 SELECT * FROM DEPARTMENTS; 

SAVEPOINT C1;

DELETE FROM DEP02 WHERE DEPARTMENT_ID = 90;

--복사 확인하기
SELECT * FROM DEP02;

ROLLBACK TO C1; --구조만 보이게 됨


--EMPLOYEES 복사해서 EMP_COPY
CREATE TABLE EMP_COPY
AS
SELECT * FROM EMPLOYEES;

SELECT * FROM EMP_COPY;

--VIEW 제거하기
DROP VIEW VIEW_EMP01;

--VIEW 생성하기(테이블생성 복사하기 똑같음)
CREATE VIEW VIEW_EMP01
AS 
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID FROM EMP_COPY WHERE DEPARTMENT_ID = 10;

--SELECT 확인학
SELECT * FROM VIEW_EMP01;
SELECT * FROM EMP_COPY WHERE EMPLOYEE_ID = 200;

--VIEW 수정하기
UPDATE VIEW_EMP01 SET SALARY = 4500 WHERE EMPLOYEE_ID = 200;

--DATA DICTIONARY(USER_TABS, USER_CONSTRATINTS, USER_CONS_COLUMNS, USER_VIEWS, USER_INDEXES)
SELECT * FROM USER_TABLES;
SELECT * FROM USER_CONSTRAINTS; --WHERE TABLE_NAME = 'EMPLOYEES';  (제약조건을 다보여줌)
SELECT * FROM USER_CONS_COLUMNS; --WHERE TABLE_NAME = 'EMPLOYEES';
SELECT * FROM USER_VIEWS;
SELECT * FROM USER_INDEXES;

--가상뷰에 입력하기(가상테이블에 컬럼 4개 입력, 원본 10개인데 그 중에 NOT NULL인데 가상테이블에 포함이 되어 있지 않으면)
INSERT INTO VIEW_EMP01 VALUES(1000, 'JDK',2000,50);
SELECT * FROM VIEW_EMP01;  

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP_COPY';

--VIEW 생성하기(테이블생성 복사하기 똑같음)
CREATE VIEW VIEW_EMP02
AS 
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID FROM EMP_COPY WHERE DEPARTMENT_ID = 10;

SELECT * FROM VIEW_EMP02; -- 가상 테이블
INSERT INTO VIEW_EMP02 VALUES(1000, 'YEON_A','KIM', '85YUNA@NAVER.COM', TO_DATE('2020/01/01','YYYY/MM/DD'),'IT_DEV');

SELECT * FROM EMP_COPY WHERE  EMPLOYEE_ID = 1000; --원본 테이블
DESC EMP_COPY; --HIRE_DATE 는 DATE로 되어있음

--VIEW3!!
CREATE VIEW VIEW_EMP03
AS 
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID FROM EMP_COPY;

SELECT * FROM VIEW_EMP03 WHERE EMPLOYEE_ID = 2000;

INSERT INTO VIEW_EMP03 VALUES(2000, 'YEON_A','KIM', '85YUNA@NAVER.COM', TO_DATE('2020/01/01','YYYY/MM/DD'),'IT_DEV');

SELECT * FROM EMP_COPY WHERE EMPLOYEE_ID = 2000;

--가상뷰에서 삭제를 진행하기
DELETE FROM VIEW_EMP03 WHERE EMPLOYEE_ID = 2000;    

--복합뷰 생성하기 (EMPLOYEES, DEPARTMENTS) 두 개의 테이블을 조인해서 새로운 가상 테이블 만들기
CREATE VIEW VIEW_EMP_DEP
AS
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, E.DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY E.DEPARTMENT_ID DESC WITH READ ONLY; --WIT READ ONLY 변경 불가능하게

SELECT * FROM VIEW_EMP_DEP;
SELECT DISTINCT DEPARTMENT_ID, DEPARTMENT_NAME FROM VIEW_EMP_DEP;  --부서명 가지고 연봉 평균 구하기
--부서명 IT 연봉 평균, 최고값, 최저값을 구해주세요
SELECT DEPARTMENT_NAME , MAX(SALARY),MIN(SALARY) FROM VIEW_EMP_DEP 
WHERE DEPARTMENT_NAME = 'IT' GROUP BY DEPARTMENT_NAME;

--VIEW FORCE (FORCE는 강제로 테이블을 만듦)
CREATE OR REPLACE FORCE VIEW VIEW_FORCE
AS
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, DEPARTMENT_ID FROM EMP20;

DESC VIEW_FORCE;

SELECT * FROM EMP20;

SELECT * FROM USER_VIEWS;

--ROWNUM
SELECT * FROM EMPLOYEES;
SELECT ROWNUM, DEPARTMENT_ID, FIRST_NAME FROM EMPLOYEES WHERE DEPARTMENT_ID = 100
ORDER BY FIRST_NAME DESC;
SELECT ROWNUM, DEPARTMENT_ID, FIRST_NAME FROM EMPLOYEES WHERE DEPARTMENT_ID = 100;

--ROWNUM 정렬하면 순서가 흐트러진 것을 다시 순차적으로 보여주고 싶을때
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES ORDER BY HIRE_DATE DESC;

CREATE VIEW VIEW_HIREDATE
AS
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES ORDER BY HIRE_DATE DESC;

SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM VIEW_HIREDATE;

SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM VIEW_HIREDATE WHERE ROWNUM = 4;


---중요 (가상뷰를 먼저 만들고 정렬시키기)
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM 
(SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES ORDER BY HIRE_DATE DESC)
WHERE ROWNUM <= 4;




